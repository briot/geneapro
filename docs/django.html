<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<title>Geneaprove @ GitHub</title>
	<style type="text/css">
body {margin:0; background-color: white; font-family: "Arial"; color: #000000}
  
#head {background-color:#39414A; padding:0 0 0 30px; margin:0; height:90px;
       background-image: -moz-linear-gradient(top, #39414A, #777); 
       background-image: -webkit-gradient(linear,left top,left bottom,color-stop(0, #39414A),color-stop(1, #777)); 
       background-image: linear-gradient(top, #39414A, #777);
       filter: progid:DXImageTransform.Microsoft.gradient(startColorStr='#39414A', EndColorStr='#777'); }

#head > a {text-decoration:none; display:block;
         font-size:3.8em; color: #ec8d05; font-style:italic;
         text-shadow: black 3px 3px 7px;}
#head .phrase{font-size:1.1em; color:white; font-style:italic;
   margin:-15px 0 0 65px; text-shadow: black 1px 1px 2px}
#head .download {float: right; margin-right:100px}

#sidebar {width:200px; float:left; height:100%}

#sidebar h2 {margin:5px 0 0 5px; padding:3px; color:white;
             font-weight:normal; font-size:1em;
             border:1px solid #39414A;
             width:187px; /* 187 = #sidebar'width - h2'margin-left - h2'padding-left
                                   - h2'padding-right */
             background:#777}
#sidebar h2.selected {background:#39414A}
#sidebar h2 a {text-decoration:none; color:white; white-space:nowrap;
   display:inline-block; width:100%}
#sidebar h2:hover,
#sidebar li:hover {background:#ec8d05}
#sidebar h2:after {position:absolute; margin-left:-10px; color:white;
    content:"\00BB"} /* see http://www.evotech.net/articles/testjsentities.html */

#sidebar ul {list-style:none; margin:8px 0 10px 20px; padding:0}
#sidebar li {width:100%}
#sidebar li a {text-decoration:none; color:black; white-space:nowrap; width:100%;
   display:inline-block}
#sidebar li a:before {content:"\00BB"; padding-right:5px}

#container {margin: 0 0 0 220px;  /* 210= #sidebar'width + 20 */
            max-width: 700px}
#container h2 {border-bottom:1px solid black}

#container img {max-width:200px; max-height:200px; margin-left:15px}
         
	</style>
</head>

<body>
  <a href="http://github.com/briot/geneapro"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>

  <div id="head">
     <div class="download">
       <a href="http://github.com/briot/geneapro/zipball/master">
          <img border="0" width="90"
               src="https://github.com/images/modules/download/zip.png"></a>
       <a href="http://github.com/briot/geneapro/tarball/master">
          <img border="0" width="90"
               src="https://github.com/images/modules/download/tar.png"></a>
    </div>
    <a href="http://github.com/briot/geneapro">G&eacute;n&eacute;aprove</a>
    <div class="phrase">Evidence your genealogy</div>
   </div>

  <div id="sidebar">
        <h2><a href="index.html">Home</a></h2>
        <h2><a href="features.html">Features</a></h2>
        <h2><a href="download.html">Download</a></h2>
        <h2 class="selected"><a href="impl.html">Implementation</a></h2>
        <ul>
           <li><a href="python.html">Python</a></li>
           <li><a href="django.html">Django</a></li>
           <li><a href="gentech.html">Gentech</a></li>
           <li><a href="links.html">Related work</a></li>
        </ul>
  </div>
  
  <div id="container">
     <h2>Django</h2>

<h3>Custom queries</h3>

<p>
Although django's database querySets are very powerful and most of the time remove the need for writing SQL queries yourself, it happens that you sometimes do have to write your own for efficiency reasons (most often to limit the number of queries sent to the database engine).
</p>

<p>
One technique I have found useful in such case is the following (from geneaprove/models.py):
</p>

<pre>
        self._p2p_query = \
           "SELECT %(p2p_assert.subj1)s FROM %(p2p_assert)s, %(assert)s" + \
           " WHERE %(p2p_assert.subj2)s=%(persona.id)s" + \
           " AND %(assert.pk)s=%(p2p_assert.pk)s" + \
           " AND %(assert.value)s='%%s' LIMIT 1"
        self._p2p_query = self._p2p_query % all_fields
        self._event_query = self._event_query % all_fields

     Persona.objects.extra (select={
           'father_id': self._p2p_query % ("father of",)})
</pre>

Where all_fields is declared as such

<pre>
def sql_table_name (cls):
    return connection.ops.quote_name (cls._meta.db_table)

def sql_field_name (cls, field_name):
    """Help write custom SQL queries"""
    if field_name == "pk":
       f = cls._meta.pk
    else:
       f = cls._meta.get_field (field_name)
    return "%s.%s" % (
       sql_table_name (cls), connection.ops.quote_name (f.column))

all_fields = {
   'assert':         sql_table_name (Assertion),
   'p2p_assert':     sql_table_name (P2P_Assertion),
   'assert.pk':      sql_field_name (Assertion, "pk"),
   'p2p_assert.pk':  sql_field_name (P2P_Assertion, "pk"),
   'p2p_assert.subj2': sql_field_name (P2P_Assertion, "subject2"),
   'p2p_assert.subj1': sql_field_name (P2P_Assertion, "subject1"),
   'persona.id'    : sql_field_name (Persona, "pk"),
   'assert.value'  : sql_field_name (Assertion, "value"),
}
</pre>

<p>
So the trick here is to use a global dict, initialized once when the application starts. wThis array hides the actual name of the fields in the database, and keeps the logical name of the model instead. If a table or a field is removed or renamed, the definition of all_fields becomes invalid and the application does not even start. 
</p>

<p>
Using a dict with your own names also makes the custom query more readable (using %(assert)s instead of %s for instance).
</p>

<h3>Automatic fields</h3>

<p>
One of the data that I often need to store in my database are dates (quite obviously for genealogical software!)
</p>
<p>
However, it is in general recommended to store dates exactly as they are found in the documents, which of course makes them harder to reuse programmatically. The solution I am using is to have two date fields in each table: one contains a TEXT of the date as found in the document, and the second one a DateTimeField which represents the result of parsing the former. That second date is in general used for sorting.
</p>
<p>
It would be tedious to add the two fields every time, so instead I created a new field type. This automatically adds a second field to the table, and whenever the data is stored into the database the second field is also updated.
</p>

<pre>
class PartialDateField (models.CharField):
    __metaclass__ = models.SubfieldBase

    def __init__ (self, max_length=0, null=True, *args, **kwargs):
        kwargs["null"]=null
        super (PartialDateField, self).__init__ (
           self, max_length=100, *args, **kwargs)

    def contribute_to_class (self, cls, name):
        sortfield = models.DateTimeField ('used to sort', null=True)
        self._sortfield = name + "_sort"
        cls.add_to_class (self._sortfield, sortfield)
        super (PartialDateField, self).contribute_to_class (cls, name)

    def pre_save(self, model_instance, add):
        val = super (PartialDateField, self).pre_save (model_instance, add)
        if val:
           sort = date.DateRange (val).sort_date ()
           setattr (model_instance, self._sortfield, sort)
        return val
</pre>


  </div>
</body>
</html>
