import {} from 'angular';
import {} from 'angular-ui-router';
import * as d3 from 'd3';
import {app} from './app';
import {IGPRootScope, IPerson} from './basetypes';
import {PedigreeService} from './pedigree.service';
import {ContextMenu} from './contextmenu';
import {GPd3Service, LayoutInfo} from './gpd3';

const html_radial = require('geneaprove/radial.html');

app.
config(($stateProvider : angular.ui.IStateProvider) => {
   $stateProvider.
   state('radial', {
      url: '/radial?id',
      templateUrl: html_radial,

      // So that when we click on a person, we change the URL (and still had
      // it to the history), but not reload the controller, since otherwise
      // any animation in SVG would not occur. See $location.search(...)
      reloadOnSearch: false,
      controller: 'radialCtrl',
      data: {
         pageTitle: '[Genaprove] Fan chart for person {{id}}'
      }
   });
});

interface RadialControllerScope extends angular.IScope {
   contextual  : any;   //  data for the contextual menu
   decujus     : number;
   focusPerson : Function;
   showPerson  : Function;
}

app.controller(
   'radialCtrl',
   ($scope       : RadialControllerScope,
    Pedigree     : PedigreeService,
    $state       : angular.ui.IStateService,
    $stateParams : angular.ui.IStateParamsService,
    contextMenu  : ContextMenu,
    $location    : angular.ILocationService) =>
{
   $scope.$on('$locationChangeSuccess', function() {
      $scope.decujus = $location.search().id || $scope.decujus;
   });
   if ($stateParams['id'] !== undefined) {
       $scope.decujus = +$stateParams['id'];
   }

   /**
    * Support for the contextual menu
    */
   $scope.$on('contextMenuOpen', () => {
      $scope.contextual = contextMenu.data;
      $scope.$apply();  // update contents of the contextual menu
   });
   $scope.focusPerson = function() {
      const id = contextMenu.data.d.id;  // capture since menu will be destroyed
      $location.search('id', id);
   };
   $scope.showPerson = function() {
      $state.go('person', {id: contextMenu.data.d.id});
   };

});

interface GPRadialScope extends angular.IScope {
   decujus : number;
}
interface RadialLayout extends LayoutInfo {
   p        : IPerson;

   // Generated by d3.layout.tree
   parent   ?: RadialLayout;
   children ?: RadialLayout[];
   depth    ?: number;
   x        ?: number;
   y        ?: number;
}

app.directive(
   'gpRadial',
   (Pedigree    : PedigreeService,
    $rootScope  : IGPRootScope,
    GPd3        : GPd3Service,
    $location   : angular.ILocationService,
    contextMenu : ContextMenu) =>
{
   return {
      scope: {
         decujus: '=gpRadial'
      },
      link: function(
         scope   : GPRadialScope,
         element : angular.IAugmentedJQuery)
      {
         const set = $rootScope.settings.radial;

         // Watch the settings (in case we want to draw differently) and the
         // decujus (in case we want to display a different person).

         scope.$watch(
            () => [scope.decujus, $rootScope.settings.radial],
            () => {
               Pedigree.select(scope.decujus);
               Pedigree.get(set.gens > 0 ? set.gens : 0,
                            set.gens < 0 ? -set.gens : 0).then(render);
            },
            true);

         const scalable = GPd3.svg(element);
         const group = scalable.selection;

         /**
          * Assuming the data is fully loaded, draw the graphics
          * @param data    as loaded from the server.
          */
         function render(data ?: PedigreeService) {
            if (!data) {
               return;
            }
            group.attr('class', 'radial color-' + set.colorScheme);

            const circleSize = 10;  // diameter of the circles
            // We are displaying gens*2+1 generations, and leave space
            // between two circles equal to 5 times the size of a circle.
            const diameter = (Math.abs(set.gens) * 2 + 1) * (circleSize * 6);

            GPd3.setViewBox(element, {x: 0, y: 0, width: diameter, height: diameter});

            const tree = d3.layout.tree<RadialLayout>()
                .size([360, diameter / 2 - 120])
                .children((d : RadialLayout) => {
                   let result : RadialLayout[] = [];
                   let base : IPerson[];

                   if (set.gens > 0) {
                      // Ancestor tree
                      if (d.p.generation > set.gens) {
                         return result;
                      }
                      base = d.p.parents;
                   } else {
                      // Descendants tree
                      if (d.p.generation < set.gens) {
                         return result;
                      }
                      base = d.p.children;
                   }

                   angular.forEach(base, (p : IPerson) => {
                      if (p) {
                         result.push(
                            <RadialLayout> {
                               p: p
                            });
                      }
                   });
                   return result;
                })
                .separation((p1 : RadialLayout, p2 : RadialLayout) => (
                   (p1.parent == p2.parent ? 1 : 2) /* / p1.depth */));

            const diagonal = d3.svg.diagonal.radial<RadialLayout>()
                .projection((d : RadialLayout) => [d.y, d.x / 180 * Math.PI]);

            d3.select(element[0]).select('svg')
                .attr("width", diameter)
                .attr("height", diameter - 150);

            const nodes = tree.nodes(<RadialLayout>{p: data.main});
            const links = tree.links(nodes);
            const styles = GPd3.getStyles(group, nodes, set, data);

            const link = group.selectAll(".link").data(links);
            link.exit().remove();
            link.enter().insert("path", ':first-child').attr("class", "link");
            link.attr("d", diagonal);

            group.selectAll('.node').remove();

            const node = group.selectAll(".node")
               // There can be multiple nodes with the same id (implex)
               .data(nodes);

            const n = node.enter().append("g").attr("class", "node")
               .on('contextmenu', (d : RadialLayout) => {
                  contextMenu.create(
                     '#contextMenu', <MouseEvent>d3.event,
                     {d: d.p, element: this});
               });
            node.attr("transform", (d : RadialLayout) => "rotate(" + (d.x - 90) + ")translate(" + d.y + ")");

            node.select('circle').remove();
            node.append("circle").attr("r", circleSize)
               .each(function(d : RadialLayout) { return d3.select(this).attr(<any>styles.style(d))})
               .attr('title', (d : RadialLayout) => data.displayName(d.p));

            node.select('text').remove();
            if (set.showText) {
               node.append("text")
                .attr({
                   dy: '.31em',
                   'text-anchor': (d : RadialLayout) => d.x < 180 ? "start" : "end",
                   'transform': (d : RadialLayout) => d.x < 180 ? "translate(8)" : "rotate(180)translate(-8)"})
                .text((d : RadialLayout) => d.p.surn);
            }

            scalable.setTranslate(diameter / 2, diameter / 2).applyScale(1);
         }
      }
   };
});
